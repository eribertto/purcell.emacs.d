Eshell

Eshell is a shell-like command interpreter implemented in Emacs Lisp. It invokes no
external processes except for those requested by the user. It is intended to be an
alternative to the IELM (see Lisp Interaction in The Emacs Editor) REPL1 for Emacs and
with an interface similar to command shells such as bash, zsh, rc, or 4dos. 

This manual is for Eshell, the Emacs shell. 

Copyright © 1999–2023 Free Software Foundation, Inc. 

 Permission is granted to copy, distribute and/or modify this document under the
 terms of the GNU Free Documentation License, Version 1.3 or any later version
 published by the Free Software Foundation; with no Invariant Sections, with the
 Front-Cover Texts being “A GNU Manual”, and with the Back-Cover Texts as in (a)
 below. A copy of the license is included in the section entitled “GNU Free
 Documentation License”. 

 (a) The FSF’s Back-Cover Text is: “You have the freedom to copy and modify this GNU
 manual.” 

Table of Contents

* 1 Introduction 

 * 1.1 What is Eshell?
 * 1.2 Contributors to Eshell

* 2 Commands 

 * 2.1 Invocation 

 * 2.1.1 Command form
 * 2.1.2 Lisp form

 * 2.2 Arguments 

 * 2.2.1 Quoting and escaping
 * 2.2.2 Special argument types

 * 2.3 Built-in commands 

 * 2.3.1 Defining new built-in commands

 * 2.4 Variables 

 * 2.4.1 Built-in variables

 * 2.5 Aliases
 * 2.6 Remote Access
 * 2.7 History
 * 2.8 Completion 

 * 2.8.1 pcomplete

 * 2.9 Control Flow
 * 2.10 Scripts

* 3 Expansion 

 * 3.1 Dollars Expansion
 * 3.2 Globbing
 * 3.3 Argument Predication and Modification 

 * 3.3.1 Argument Predicates
 * 3.3.2 Argument Modifiers

* 4 Input/Output 

 * 4.1 Visual Commands
 * 4.2 Redirection 

 * 4.2.1 Virtual Targets

 * 4.3 Pipelines 

 * 4.3.1 Running Shell Pipelines Natively

* 5 Extension modules 

 * 5.1 Optional modules 

 * 5.1.1 Key rebinding
 * 5.1.2 Smart scrolling
 * 5.1.3 Electric forward slash
 * 5.1.4 Tramp extensions
 * 5.1.5 Extra built-in commands

 * 5.2 Writing a module

* 6 Bugs and ideas
* Appendix A GNU Free Documentation License
* Concept Index
* Function and Variable Index
* Command Index

-----------------------------------------------------------------------------------------------

Next: Commands, Previous: Eshell, Up: Eshell   [Contents][Index]

1 Introduction

* What is Eshell?
* Contributors to Eshell

1.1 What is Eshell?

Eshell is a command shell written in Emacs Lisp. Everything it does, it uses Emacs’s
facilities to do. This means that Eshell is as portable as Emacs itself. It also means
that cooperation with Lisp code is natural and seamless. 

What is a command shell? To properly understand the role of a shell, it’s necessary to
visualize what a computer does for you. Basically, a computer is a tool; in order to
use that tool, you must tell it what to do—or give it “commands.” These commands take
many forms, such as clicking with a mouse on certain parts of the screen. But that is
only one form of command input. 

By far the most versatile way to express what you want the computer to do is by using
an abbreviated language called script. In script, instead of telling the computer,
“list my files, please”, one writes a standard abbreviated command word—‘ls’. Typing
‘ls’ in a command shell is a script way of telling the computer to list your files.2 

The real flexibility of this approach is apparent only when you realize that there are
many, many different ways to list files. Perhaps you want them sorted by name, sorted
by date, in reverse order, or grouped by type. Most graphical browsers have simple
ways to express this. But what about showing only a few files, or only files that meet
a certain criteria? In very complex and specific situations, the request becomes too
difficult to express using a mouse or pointing device. It is just these kinds of
requests that are easily solved using a command shell. 

For example, what if you want to list every Word file on your hard drive, larger than
100 kilobytes in size, and which hasn’t been looked at in over six months? That is a
good candidate list for deletion, when you go to clean up your hard drive. But have
you ever tried asking your computer for such a list? There is no way to do it! At
least, not without using a command shell. 

The role of a command shell is to give you more control over what your computer does
for you. Not everyone needs this amount of control, and it does come at a cost:
Learning the necessary script commands to express what you want done. A complicated
query, such as the example above, takes time to learn. But if you find yourself using
your computer frequently enough, it is more than worthwhile in the long run. Any tool
you use often deserves the time spent learning to master it. 3 

-----------------------------------------------------------------------------------------------

Up: Introduction   [Contents][Index]

1.2 Contributors to Eshell

Contributions to Eshell are welcome. I have limited time to work on this project, but
I will gladly add any code you contribute to me to this package. 

The following persons have made contributions to Eshell. 

* John Wiegley is the original author of Eshell. 
* Eli Zaretskii made it possible for Eshell to run without requiring asynchronous
 subprocess support. This is important for MS-DOS, which does not have such support. 
* Miles Bader contributed many fixes during the port to Emacs 21. 
* Stefan Monnier fixed the things which bothered him, which of course made things
 better for all. 
* Gerd Moellmann also helped to contribute bug fixes during the initial integration
 with Emacs 21. 
* Alex Schroeder contributed code for interactively querying the user before
 overwriting files. 

Apart from these, a lot of people have sent suggestions, ideas, requests, bug reports
and encouragement. Thanks a lot! Without you there would be no new releases of Eshell.

-----------------------------------------------------------------------------------------------

Next: Expansion, Previous: Introduction, Up: Eshell   [Contents][Index]

2 Commands

In a command shell, everything is done by invoking commands. This chapter covers
command invocations in Eshell, including the command history and invoking commands in
a script file. 

Unlike regular system shells, Eshell never invokes kernel functions directly, such as
exec(3). Instead, it uses the Lisp functions available in the Emacs Lisp library. It
does this by transforming the input line into a callable Lisp form.4 

* Invocation
* Arguments
* Built-in commands
* Variables
* Aliases
* Remote Access
* History
* Completion
* Control Flow
* Scripts

-----------------------------------------------------------------------------------------------

Next: Arguments, Up: Commands   [Contents][Index]

2.1 Invocation

Eshell is both a command shell and an Emacs Lisp REPL. As a result, you can invoke
commands in two different ways: in command form or in Lisp form. 

You can use the semicolon (;) to separate multiple command invocations on a single
line, executing each in turn. You can also separate commands with && or ||. When using
&&, Eshell will execute the second command only if the first succeeds (i.e. has an exit
status of 0); with ||, Eshell will execute the second command only if the first fails. 

A command invocation followed by an ampersand (&) will be run in the background.
Eshell has no job control, so you can not suspend or background the current process,
or bring a background process into the foreground. That said, background processes
invoked from Eshell can be controlled the same way as any other background process in
Emacs. 

* Command form
* Lisp form

2.1.1 Command form

Command form looks much the same as in other shells. A command consists of arguments
separated by spaces; the first argument is the command to run, with any subsequent
arguments being passed to that command. 

~ $ echo hello
hello

The command can be either an Elisp function or an external command. Eshell looks for
the command in the following order: 

1 As a command alias (see Aliases) 
2 As a built-in command (see Built-in commands) 
3 As an external program 
4 As an ordinary Lisp function 

If you would prefer to use ordinary Lisp functions over external programs, set the
option eshell-prefer-lisp-functions to t. This will swap the lookup order of the last two
items. You can also force Eshell to look for a command as an external program by
prefixing its name with *, like *command (see Built-in commands). 

You can also group command forms together into a subcommand with curly braces ({}).
This lets you use the output of a subcommand as an argument to another command, or
within control flow statements (see Control Flow). 

~ $ echo {echo hello; echo there}
hellothere

2.1.2 Lisp form

Lisp form looks like ordinary Emacs Lisp code, because that’s what it is. As a result,
you can use any syntax normally available to an Emacs Lisp program (see The Emacs Lisp
Reference Manual). 

~ $ (format "hello, %s" user-login-name)
hello, user

In addition, you can combine command forms and Lisp forms together into single
statements, letting you use whatever form is the most convenient for expressing your
intentions. 

~ $ ls *.patch > (format-time-string "%F.log")

This command writes a list of all files matching the glob pattern *.patch (see
Globbing) to a file named current-date.log (see Redirection). 

-----------------------------------------------------------------------------------------------

Next: Built-in commands, Previous: Invocation, Up: Commands   [Contents][Index]

2.2 Arguments

Ordinarily, Eshell parses arguments in command form as either strings or numbers,
depending on what the parser thinks they look like. To specify an argument of some
other data type, you can use a Lisp form (see Invocation): 

~ $ echo (list 1 2 3)
(1 2 3)

Additionally, many built-in Eshell commands (see Built-in commands) will flatten the
arguments they receive, so passing a list as an argument will “spread” the elements
into multiple arguments: 

~ $ printnl (list 1 2) 3
1
2
3

* Quoting and escaping
* Special argument types

2.2.1 Quoting and escaping

As with other shells, you can escape special characters and spaces by prefixing the
character with a backslash (‘\’), or by surrounding the string with apostrophes (‘''’)
or double quotes (‘""’). This is needed especially for file names with special
characters like pipe (‘|’), which could be part of remote file names. 

When you escape a character with ‘\’ outside of any quotes, the result is the literal
character immediately following it. For example, \$10 means the literal string $10. 

Inside of double quotes, most characters have no special meaning. However, ‘\’, ‘"’,
and ‘$’ are still special; to escape them, use backslash as above. Thus, if the value
of the variable answer is 42, then "The answer is: \"$answer\"" returns the string The
answer is: "42". However, when escaping characters with no special meaning, the result
is the full \c sequence. For example, "foo\bar" means the literal string foo\bar. 

Additionally, when escaping a newline, the whole escape sequence is removed by the
parser. This lets you continue commands across multiple lines: 

~ $ echo "foo\
bar"
foobar

Inside apostrophes, escaping works differently. All characters between the apostrophes
have their literal meaning except ‘'’, which ends the quoted string. To insert a
literal apostrophe, you can use ‘''’, so 'It''s me' means the literal string It's me. 

When using expansions (see Expansion) in an Eshell command, the result may potentially
be of any data type. To ensure that the result is always a string, the expansion can
be surrounded by double quotes. 

2.2.2 Special argument types

In addition to strings and numbers, Eshell supports a number of special argument
types. These let you refer to various other Emacs Lisp data types, such as lists or
buffers. 

#'lisp-form

 This refers to the quoted Emacs Lisp form lisp-form. Though this looks similar to
 the “sharp quote” syntax for functions (see Special Read Syntax in The Emacs Lisp
 Reference Manual), it instead corresponds to quote and can be used for any quoted
 form.5 

`lisp-form

 This refers to the backquoted Emacs Lisp form lisp-form (see Backquote in The Emacs
 Lisp Reference Manual). As in Emacs Lisp, you can use ‘,’ and ‘,@’ to refer to
 non-constant values. 

#<buffer name>
#<name>

 Return the buffer named name. This is equivalent to ‘$(get-buffer-create "name")’
 (see Creating Buffers in The Emacs Lisp Reference Manual). 

#<process name>

 Return the process named name. This is equivalent to ‘$(get-process "name")’ (see
 Process Information in The Emacs Lisp Reference Manual). 

-----------------------------------------------------------------------------------------------

Next: Variables, Previous: Arguments, Up: Commands   [Contents][Index]

2.3 Built-in commands

Eshell provides a number of built-in commands, many of them implementing common
command-line utilities, but enhanced for Eshell. (These built-in commands are just
ordinary Lisp functions whose names begin with eshell/.) In order to call the external
variant of a built-in command foo, you could call *foo. Usually, this should not be
necessary. You can check what will be applied by the which command: 

~ $ which ls
eshell/ls is a compiled Lisp function in `em-ls.el'
~ $ which *ls
/bin/ls

If you want to discard a given built-in command, you could declare an alias (see
Aliases). Example: 

~ $ which sudo
eshell/sudo is a compiled Lisp function in `em-tramp.el'.
~ $ alias sudo '*sudo $*'
~ $ which sudo
sudo is an alias, defined as "*sudo $*"

Some of the built-in commands have different behavior from their external
counterparts, and some have no external counterpart. Most of these will print a usage
message when given the --help option. 

In some cases, a built-in command’s behavior can be configured via user settings, some
of which are mentioned below. For example, certain commands have two user settings to
allow them to overwrite files without warning and to ensure that they always prompt
before overwriting files. If both settings are non-nil, the commands always prompt. If
both settings are nil (the default), the commands signal an error. 

Several commands observe the value of eshell-default-target-is-dot. If non-nil, then the
default target for the commands cp, mv, and ln is the current directory. 

A few commands are wrappers for more niche Emacs features, and can be loaded as part
of the eshell-xtra module. See Extension modules. 

. ¶

 Source an Eshell file in the current environment. This is not to be confused with
 the command source, which sources a file in a subshell environment. 

addpath ¶

 Adds a given path or set of paths to the PATH environment variable, or, with no
 arguments, prints the current paths in this variable. 

alias ¶

 Define an alias (see Aliases). This adds it to the aliases file. 

basename ¶

 Return a file name without its directory. 

cat ¶

 Concatenate file contents into standard output. If in a pipeline, or if the file is
 not a regular file, directory, or symlink, then this command reverts to the
 system’s definition of cat. 

cd ¶

 This command changes the current working directory. Usually, it is invoked as cd
 dir where dir is the new working directory. But cd knows about a few special
 arguments: 

 * When it receives no argument at all, it changes to the home directory. 
 * Giving the command cd - changes back to the previous working directory (this is
 the same as cd $-). 
 * The command cd = shows the directory ring. Each line is numbered. 
 * With cd =foo, Eshell searches the directory ring for a directory matching the
 regular expression ‘foo’, and changes to that directory. 
 * With cd -42, you can access the directory stack slots by number. 
 * If eshell-cd-shows-directory is non-nil, cd will report the directory it changes
 to. If eshell-list-files-after-cd is non-nil, then ls is called with any remaining
 arguments after changing directories. 

clear ¶

 Scrolls the contents of the Eshell window out of sight, leaving a blank window. If
 provided with an optional non-nil argument, the scrollback contents are cleared
 instead. 

clear-scrollback ¶

 Clear the scrollback contents of the Eshell window. Unlike the command clear, this
 command deletes content in the Eshell buffer. 

cp ¶

 Copy a file to a new location or copy multiple files to the same directory. 

 If eshell-cp-overwrite-files is non-nil, then cp will overwrite files without
 warning. If eshell-cp-interactive-query is non-nil, then cp will ask before
 overwriting anything. 

date ¶

 Print the current local time as a human-readable string. This command is similar
 to, but slightly different from, the GNU Coreutils date command. 

diff ¶

 Compare files using Emacs’s internal diff (not to be confused with ediff). See
 Comparing Files in The GNU Emacs Manual. 

 If eshell-plain-diff-behavior is non-nil, then this command does not use Emacs’s
 internal diff. This is the same as using ‘alias diff '*diff $*'’. 

dirname ¶

 Return the directory component of a file name. 

dirs ¶

 Prints the directory stack. Directories can be added or removed from the stack
 using the commands pushd and popd, respectively. 

du ¶

 Summarize disk usage for each file. 

echo ¶

 Echoes its input. By default, this prints in a Lisp-friendly fashion (so that the
 value is useful to a Lisp command using the result of echo as an argument). If a
 single argument is passed, echo prints that; if multiple arguments are passed, it
 prints a list of all the arguments; otherwise, it prints the empty string. 

 If eshell-plain-echo-behavior is non-nil, echo will try to behave more like a plain
 shell’s echo, printing each argument as a string, separated by a space. 

env ¶

 Prints the current environment variables. Unlike in Bash, this command does not yet
 support running commands with a modified environment. 

eshell-debug ¶

 Toggle debugging information for Eshell itself. You can pass this command the
 argument errors to enable/disable Eshell trapping errors when evaluating commands,
 or the argument commands to show/hide command execution progress in the buffer
 *eshell last cmd*. 

exit ¶

 Exit Eshell and save the history. By default, this command kills the Eshell buffer,
 but if eshell-kill-on-exit is nil, then the buffer is merely buried instead. 

export ¶

 Set environment variables using input like Bash’s export, as in ‘export var1=val1
 var2=val2 …’. 

grep ¶
agrep
egrep
fgrep
glimpse

 The grep commands are compatible with GNU grep, but use Emacs’s internal grep
 instead. See Grep Searching in The GNU Emacs Manual. 

 If eshell-plain-grep-behavior is non-nil, then these commands do not use Emacs’s
 internal grep. This is the same as using ‘alias grep '*grep $*'’, though this
 setting applies to all of the built-in commands for which you would need to create
 a separate alias. 

history ¶

 Prints Eshell’s input history. With a numeric argument N, this command prints the N
 most recent items in the history. 

info ¶

 Browse the available Info documentation. This command is the same as the external
 info command, but uses Emacs’s internal Info reader. See Misc Help in The GNU Emacs
 Manual. 

jobs ¶

 List subprocesses of the Emacs process, if any, using the function list-processes. 

kill ¶

 Kill processes. Takes a PID or a process object and an optional signal specifier
 which can either be a number or a signal name. 

listify ¶

 Eshell version of list. Allows you to create a list using Eshell syntax, rather
 than Elisp syntax. For example, ‘listify foo bar’ and ("foo" "bar") both evaluate to
 ("foo" "bar"). 

ln ¶

 Create links to files. 

 If eshell-ln-overwrite-files is non-nil, ln will overwrite files without warning. If
 eshell-ln-interactive-query is non-nil, then ln will ask before overwriting files. 

locate ¶

 Alias to Emacs’s locate function, which simply runs the external locate command and
 parses the results. See Dired and Find in The GNU Emacs Manual. 

 If eshell-plain-locate-behavior is non-nil, then Emacs’s internal locate is not used.
 This is the same as using ‘alias locate '*locate $*'’. 

ls ¶

 Lists the contents of directories. 

 If eshell-ls-use-colors is non-nil, the contents of a directory is color-coded
 according to file type and status. These colors and the regexps used to identify
 their corresponding files can be customized via M-x customize-group RET eshell-ls
 RET. 

 The user option eshell-ls-date-format determines how the date is displayed when using
 the -l option. The date is produced using the function format-time-string (see Time
 Parsing in GNU Emacs Lisp Reference Manual). 

 The user option eshell-ls-initial-args contains a list of arguments to include with
 any call to ls. For example, you can include the option -h to always use a more
 human-readable format. 

 The user option eshell-ls-default-blocksize determines the default blocksize used
 when displaying file sizes with the option -s. 

make ¶

 Run make through compile when run asynchronously (e.g., ‘make &’). See Compilation
 in The GNU Emacs Manual. Otherwise call the external make command. 

man ¶

 Display Man pages using the Emacs man command. See Man Page in The GNU Emacs
 Manual. 

mkdir ¶

 Make new directories. 

mv ¶

 Move or rename files. 

 If eshell-mv-overwrite-files is non-nil, mv will overwrite files without warning. If
 eshell-mv-interactive-query is non-nil, mv will prompt before overwriting anything. 

occur ¶

 Alias to Emacs’s occur. See Other Repeating Search in The GNU Emacs Manual. 

popd ¶

 Pop a directory from the directory stack and switch to a another place in the
 stack. 

printnl ¶

 Print the arguments separated by newlines. 

pushd ¶

 Push the current directory onto the directory stack, then change to another
 directory. 

 If eshell-pushd-dunique is non-nil, then only unique directories will be added to the
 stack. If eshell-pushd-dextract is non-nil, then ‘pushd +n’ will pop the nth
 directory to the top of the stack. 

pwd ¶

 Prints the current working directory. 

rm ¶

 Removes files, buffers, processes, or Emacs Lisp symbols, depending on the
 argument. 

 If eshell-rm-interactive-query is non-nil, rm will prompt before removing anything.
 If eshell-rm-removes-directories is non-nil, then rm can also remove directories.
 Otherwise, rmdir is required. 

rmdir ¶

 Removes directories if they are empty. 

set ¶

 Set variable values, using the function set like a command (see Setting Variables
 in GNU Emacs Lisp Reference Manual). A variable name can be a symbol, in which case
 it refers to a Lisp variable, or a string, referring to an environment variable
 (see Arguments). 

setq ¶

 Set variable values, using the function setq like a command (see Setting Variables
 in GNU Emacs Lisp Reference Manual). 

source ¶

 Source an Eshell file in a subshell environment. This is not to be confused with
 the command ., which sources a file in the current environment. 

time ¶

 Show the time elapsed during a command’s execution. 

umask ¶

 Set or view the default file permissions for newly created files and directories. 

unset ¶

 Unset one or more variables. As with set, a variable name can be a symbol, in which
 case it refers to a Lisp variable, or a string, referring to an environment
 variable. 

wait ¶

 Wait until a process has successfully completed. 

which ¶

 Identify a command and its location. 

whoami ¶

 Print the current user. This Eshell version of whoami supports Tramp. 

* Defining new built-in commands

2.3.1 Defining new built-in commands

While Eshell can run Lisp functions directly as commands, it may be more convenient to
provide a special built-in command for Eshell. Built-in commands are just ordinary
Lisp functions designed to be called from Eshell. When defining an Eshell-specific
version of an existing function, you can give that function a name starting with
eshell/ so that Eshell knows to use it. 

Macro: eshell-eval-using-options name macro-args options body… ¶

 This macro processes a list of macro-args for the command name using a set of
 command line options. If the arguments are parsed successfully, it will store the
 resulting values in local symbols and execute body; any remaining arguments will be
 available in the locally let-bound variable args. The return value is the value of
 the last form in body. 

 If an unknown option was passed in macro-args and an external command was specified
 (see below), this macro will start a process for that command and throw the tag
 eshell-external with the new process as its value. 

 options should be a list beginning with one or more elements of the following form,
 with each element representing a particular command-line switch: 

(short long value symbol help-string)

 short

 This element, if non-nil, should be a character to be used as a short switch,
 like -short. At least one of this element and long must be non-nil. 

 long

 This element, if non-nil, should be a string to be used as a long switch, like -
 -long. 

 value

 This element is the value associated with the option. It can be either: 

 t

 The option needs a value to be specified after the switch. 

 nil

 The option is given the value t. 

 anything else

 The option is given the specified value. 

 symbol

 This element is the Lisp symbol that will be bound to value. If symbol is nil,
 specifying this switch will instead call eshell-show-usage, and so is appropriate
 for an option like --help. 

 help-string

 This element is a documentation string for the option, which will be displayed
 when eshell-show-usage is invoked. 

 After the list of command-line switch elements, options can include additional
 keyword arguments to control how eshell-eval-using-options behaves. Some of these
 take arguments, while others don’t. The recognized keywords are: 

 :external string

 Specify string as an external command to run if there are unknown switches in
 macro-args. 

 :usage string

 Set string as the initial part of the command’s documentation string. It
 appears before the options are listed. 

 :post-usage string

 Set string to be the (optional) trailing part of the command’s documentation
 string. It appears after the list of options, but before the final part of the
 documentation about the associated external command, if there is one. 

 :show-usage

 If present, then show the usage message if the command is called with no
 arguments. 

 :preserve-args

 Normally, eshell-eval-using-options flattens the list of arguments in macro-args
 and converts each to a string. If this keyword is present, avoid doing that,
 instead preserving the original arguments. This is useful for commands which
 want to accept arbitrary Lisp objects. 

 :parse-leading-options-only

 If present, do not parse dash or switch arguments after the first positional
 argument. Instead, treat them as positional arguments themselves. 

 For example, you could handle a subset of the options for the ls command like this:

(eshell-eval-using-options
 "ls" macro-args
 '((?a  nil      nil show-all       "show all files")
   (?I  "ignore" t   ignore-pattern "ignore files matching pattern")
   (nil "help"   nil nil            "show this help message")
 :external "ls"
 :usage "[OPTION]... [FILE]...
  List information about FILEs (the current directory by default).")
 ;; List the files in ARGS somehow...
 )

-----------------------------------------------------------------------------------------------

Next: Aliases, Previous: Built-in commands, Up: Commands   [Contents][Index]

2.4 Variables

Since Eshell is a combination of an Emacs REPL and a command shell, it can refer to
variables from two different sources: ordinary Emacs Lisp variables, as well as
environment variables. By default, when using a variable in Eshell, it will first look
in the list of built-in variables, then in the list of environment variables, and
finally in the list of Lisp variables. If you would prefer to use Lisp variables over
environment variables, you can set eshell-prefer-lisp-variables to t. 

You can set variables in a few different ways. To set a Lisp variable, you can use the
command ‘setq name value’, which works much like its Lisp counterpart (see Setting
Variables in The Emacs Lisp Reference Manual). To set an environment variable, use
‘export name=value’. You can also use ‘set variable value’, which sets a Lisp variable
if variable is a symbol, or an environment variable if it’s a string (see Arguments).
Finally, you can temporarily set environment variables for a single command with
‘name=value command …’. This is equivalent to: 

{
  export name=value
  command …
}

* Built-in variables

2.4.1 Built-in variables

Eshell knows a few built-in variables: 

$PWD
$+

 This variable always contains the current working directory. 

$OLDPWD
$-

 This variable always contains the previous working directory (the current working
 directory from before the last cd command). When using $-, you can also access
 older directories in the directory ring via subscripting, e.g. ‘$-[1]’ refers to
 the working directory before the previous one. 

$PATH

 This specifies the directories to search for executable programs. Its value is a
 string, separated by ":" for Unix and GNU systems, and ";" for MS systems. This
 variable is connection-aware, so whenever you change the current directory to a
 different host (see Remote Files in The GNU Emacs Manual), the value will
 automatically update to reflect the search path on that host. 

$_

 This refers to the last argument of the last command. With a subscript, you can
 access any argument of the last command. For example, ‘$_[1]’ refers to the second
 argument of the last command (excluding the command name itself). 

$$

 This is the result of the last command. For external commands, it is t if the exit
 code was 0 or nil otherwise. 

$?

 This variable contains the exit code of the last command. If the last command was a
 Lisp function, it is 0 for successful completion or 1 otherwise. If
 eshell-lisp-form-nil-is-failure is non-nil, then a command with a Lisp form, like
 ‘(command args…)’, that returns nil will set this variable to 2. 

$COLUMNS
$LINES

 These variables tell the number of columns and lines, respectively, that are
 currently visible in the Eshell window. They are both copied to the environment, so
 external commands invoked from Eshell can consult them to do the right thing. 

$INSIDE_EMACS

 This variable indicates to external commands that they are being invoked from
 within Emacs so they can adjust their behavior if necessary. By default, its value
 is emacs-version,eshell. Other parts of Emacs, such as Tramp, may add extra
 information to this value. 

See Aliases, for the built-in variables ‘$*’, ‘$1’, ‘$2’, …, in alias definitions. 

-----------------------------------------------------------------------------------------------

Next: Remote Access, Previous: Variables, Up: Commands   [Contents][Index]

2.5 Aliases

Aliases are commands that expand to a longer input line. For example, ll is a common
alias for ls -l, and would be defined with the command invocation alias ll 'ls -l $*';
with this defined, running ‘ll foo’ in Eshell will actually run ‘ls -l foo’. Aliases
defined (or deleted) by the alias command are automatically written to the file named
by eshell-aliases-file, which you can also edit directly (although you will have to
manually reload it). 

Note that unlike aliases in Bash, arguments must be handled explicitly. Typically the
alias definition would end in ‘$*’ to pass all arguments along. More selective use of
arguments via ‘$1’, ‘$2’, etc., is also possible. For example, alias mcd 'mkdir $1 &&
cd $1' would cause mcd foo to create and switch to a directory called ‘foo’. 

-----------------------------------------------------------------------------------------------

Next: History, Previous: Aliases, Up: Commands   [Contents][Index]

2.6 Remote Access

Since Eshell uses Emacs facilities for most of its functionality, you can access
remote hosts transparently. To connect to a remote host, simply cd into it: 

~ $ cd /ssh:user@remote:
/ssh:user@remote:~ $

Additionally, built-in Eshell commands (see Built-in commands) and ordinary Lisp
functions accept remote file names, so you can access them even without explicitly
connecting first. For example, to print the contents of a remote file, you could type
‘cat /ssh:user@remote:~/output.log’. However, this means that when using built-in
commands or Lisp functions from a remote directory, you must be careful about
specifying absolute file names: ‘cat /var/output.log’ will always print the contents
of your local /var/output.log, even from a remote directory. If you find this behavior
annoying, you can enable the optional electric forward slash module (see Electric
forward slash). 

-----------------------------------------------------------------------------------------------

Next: Completion, Previous: Remote Access, Up: Commands   [Contents][Index]

2.7 History

The ‘history’ command shows all commands kept in the history ring as numbered list. If
the history ring contains eshell-history-size commands, those numbers change after every
command invocation, therefore the ‘history’ command shall be applied before using the
expansion mechanism with history numbers. 

The n-th entry of the history ring can be applied with the ‘!n’ command. If n is
negative, the entry is counted from the end of the history ring. 

When history event designators are enabled (by adding eshell-expand-history-references to
eshell-expand-input-functions), ‘!foo’ expands to the last command beginning with foo,
and ‘!?foo’ to the last command containing foo. The n-th argument of the last command
beginning with foo is accessible by !foo:n. 

The history ring is loaded from a file at the start of every session, and written back
to the file at the end of every session. The file path is specified in
eshell-history-file-name. Unlike other shells, such as Bash, Eshell can not be
configured to keep a history ring of a different size than that of the history file. 

Since the default buffer navigation and searching key-bindings are still present in
the Eshell buffer, the commands for history navigation and searching are bound to
different keys: 

M-r
M-s

 History I-search. 

M-p
M-n

 Previous and next history line. If there is anything on the input line when you run
 these commands, they will instead jump to the previous or next line that begins
 with that string. 

-----------------------------------------------------------------------------------------------

Next: Control Flow, Previous: History, Up: Commands   [Contents][Index]

2.8 Completion

Eshell uses the pcomplete package for programmable completion, similar to that of
other command shells. Argument completion differs depending on the preceding command:
for example, possible completions for rmdir are only directories, while rm completions
can be directories and files. Eshell provides predefined completions for the built-in
functions and some common external commands, and you can define your own for any
command. 

Eshell completion also works for Lisp forms and glob patterns. If the point is on a
Lisp form, then TAB will behave similarly to completion in elisp-mode and
lisp-interaction-mode. For glob patterns, the pattern will be removed from the input
line, and replaced by the completion. 

If you want to see the entire list of possible completions (e.g. when it’s below the
completion-cycle-threshold), press M-?. 

* pcomplete

2.8.1 pcomplete

Pcomplete, short for programmable completion, is the completion library originally
written for Eshell, but usable for command completion6 in other modes. 

Completions are defined as functions (with defun) named pcomplete/COMMAND, where COMMAND
is the name of the command for which this function provides completions; you can also
name the function pcomplete/MAJOR-MODE/COMMAND to define completions for a specific major
mode. 

-----------------------------------------------------------------------------------------------

Next: Scripts, Previous: Completion, Up: Commands   [Contents][Index]

2.9 Control Flow

Because Eshell commands can not (easily) be combined with Lisp forms, Eshell provides
command-oriented control flow statements for convenience. 

Most of Eshell’s control flow statements accept a conditional. This can take a few
different forms. If conditional is a dollar expansion, the condition is satisfied if
the result is a non-nil value. If conditional is a ‘{ subcommand }’ or ‘(lisp form)’,
the condition is satisfied if the command’s exit status is 0. 

if conditional { true-commands }
if conditional { true-commands } { false-commands }

 Evaluate true-commands if conditional is satisfied; otherwise, evaluate
 false-commands. 

unless conditional { false-commands }
unless conditional { false-commands } { true-commands }

 Evaluate false-commands if conditional is not satisfied; otherwise, evaluate
 true-commands. 

while conditional { commands }

 Repeatedly evaluate commands so long as conditional is satisfied. 

until conditional { commands }

 Repeatedly evaluate commands until conditional is satisfied. 

for var in list… { commands }

 Iterate over each element of list, storing the element in var and evaluating
 commands. If list is not a list, treat it as a list of one element. If you specify
 multiple lists, this will iterate over each of them in turn. 

-----------------------------------------------------------------------------------------------

Previous: Control Flow, Up: Commands   [Contents][Index]

2.10 Scripts

You can run Eshell scripts much like scripts for other shells; the main difference is
that since Eshell is not a system command, you have to run it from within Emacs. An
Eshell script is simply a file containing a sequence of commands, as with almost any
other shell script. Scripts are invoked from Eshell with source, or from anywhere in
Emacs with eshell-source-file. 

If you wish to load a script into your current environment, rather than in a subshell,
use the . command. 

-----------------------------------------------------------------------------------------------

Next: Input/Output, Previous: Commands, Up: Eshell   [Contents][Index]

3 Expansion

Expansion in a command shell is somewhat like macro expansion in macro parsers (such
as cpp and m4), but in a command shell, they are less often used for constants, and
usually for using variables and string manipulation.7 For example, $var on a line
expands to the value of the variable var when the line is executed. Expansions are
usually passed as arguments, but may also be used as commands.8 

You can concatenate expansions with regular string arguments or even other expansions.
In the simplest case, when the expansion returns a string value, this is equivalent to
ordinary string concatenation; for example, ‘${echo "foo"}bar’ returns ‘foobar’. The
exact behavior depends on the types of each value being concatenated: 

both strings

 Concatenate both values together. 

one or both numbers

 Concatenate the string representation of each value, converting back to a number if
 possible. 

one or both (non-nil) lists

 Concatenate “adjacent” elements of each value (possibly converting back to a number
 as above). For example, ‘$(list "a" "b")c’ returns ‘("a" "bc")’. 

anything else

 Concatenate the string representation of each value. 

* Dollars Expansion
* Globbing
* Argument Predication and Modification

-----------------------------------------------------------------------------------------------

Next: Globbing, Up: Expansion   [Contents][Index]

3.1 Dollars Expansion

Eshell has different $ expansion syntax from other shells. There are some
similarities, but don’t let these lull you into a false sense of familiarity. 

$var

 Expands to the value bound to var. This is the main way to use variables in command
 invocations. 

$"var"
$'var'

 Expands to the value bound to var. This is useful to disambiguate the variable name
 when concatenating it with another value, such as ‘$"var"-suffix’. 

$(lisp)

 Expands to the result of evaluating the S-expression (lisp). On its own, this is
 identical to just (lisp), but with the $, it can be used inside double quotes or
 within a longer string, such as ‘/some/path/$(lisp).txt’. 

${command}

 Returns the output of command, which can be any valid Eshell command invocation,
 and may even contain expansions. Similar to $(lisp), this is identical to {command}
 when on its own, but the $ allows it to be used inside double quotes or as part of
 a string. 

 Normally, the output is split line-by-line, returning a list (or the first element
 if there’s only one line of output); if eshell-convert-numeric-arguments is non-nil
 and every line of output looks like a number, convert each line to a number.
 However, when this expansion is surrounded by double quotes, it returns the output
 as a single string instead. 

$<command>

 As with ‘${command}’, evaluates the Eshell command invocation command, but writes
 the output to a temporary file and returns the file name. 

$expr[i...]

 Expands to the ith element of the result of expr, an expression in one of the above
 forms listed here. If multiple indices are supplied, this will return a list
 containing the elements for each index. The exact behavior depends on the type of
 expr’s value: 

 a sequence

 Expands to the element at the (zero-based) index i of the sequence (see
 Sequences Arrays Vectors in The Emacs Lisp Reference Manual). 

 a string

 Split the string at whitespace, and then expand to the ith element of the
 resulting sequence. 

 an alist

 If i is a non-numeric value, expand to the value associated with the key "i" in
 the alist. For example, if var is ‘(("dog" . "fido") ("cat" . "felix"))’, then
 ‘$var[dog]’ expands to "fido". Otherwise, this behaves as with sequences; e.g.,
 ‘$var[0]’ expands to ("dog" . "fido"). See Association Lists in The Emacs Lisp
 Reference Manual. 

 anything else

 Signals an error. 

 Multiple sets of indices can also be specified. For example, if var is ‘((1 2) (3
 4))’, then ‘$var[0][1]’ will expand to 2, i.e. the second element of the first list
 member (all indices are zero-based). 

$expr[regexp i...]

 As above (when expr expands to a string), but use regexp to split the string.
 regexp can be any form other than a number. For example, ‘$var[: 0]’ will return
 the first element of a colon-delimited string. 

$#expr

 Expands to the length of the result of expr, an expression in one of the above
 forms. For example, ‘$#var’ returns the length of the variable var and ‘$#var[0]’
 returns the length of the first element of var. Again, signals an error if the
 result of expr is not a string or a sequence. 

-----------------------------------------------------------------------------------------------

Next: Argument Predication and Modification, Previous: Dollars Expansion, Up:
Expansion   [Contents][Index]

3.2 Globbing

Eshell’s globbing syntax is very similar to that of Zsh (see Filename Generation in
The Z Shell Manual). Users coming from Bash can still use Bash-style globbing, as
there are no incompatibilities. 

By default, globs are case sensitive, except on MS-DOS/MS-Windows systems. You can
control this behavior via the eshell-glob-case-insensitive option. You can further
customize the syntax and behavior of globbing in Eshell via the Customize group
eshell-glob (see Easy Customization in The GNU Emacs Manual). 

‘*’

 Matches any string (including the empty string). For example, ‘*.el’ matches any
 file with the .el extension. 

‘?’

 Matches any single character. For example, ‘?at’ matches cat and bat, but not goat.

‘**/’

 Matches zero or more subdirectories in a file name. For example, ‘**/foo.el’
 matches foo.el, bar/foo.el, bar/baz/foo.el, etc. Note that this cannot be combined
 with any other patterns in the same file name segment, so while ‘foo/**/bar.el’ is
 allowed, ‘foo**/bar.el’ is not. 

‘***/’

 Like ‘**/’, but follows symlinks as well. 

‘[ … ]’

 Defines a character set (see Regexps in The GNU Emacs Manual). A character set
 matches characters between the two brackets; for example, ‘[ad]’ matches a and d.
 You can also include ranges of characters in the set by separating the start and
 end with ‘-’. Thus, ‘[a-z]’ matches any lower-case ASCII letter. Note that, unlike
 in Zsh, character ranges are interpreted in the Unicode codepoint order, not in the
 locale-dependent collation order. 

 Additionally, you can include character classes in a character set. A ‘[:’ and
 balancing ‘:]’ enclose a character class inside a character set. For instance,
 ‘[[:alnum:]]’ matches any letter or digit. See Char Classes in The Emacs Lisp
 Reference Manual, for a list of character classes. 

‘[^ … ]’

 Defines a complemented character set. This behaves just like a character set, but
 matches any character except the ones specified. 

‘( … )’

 Defines a group. A group matches the pattern between ‘(’ and ‘)’. Note that a group
 can only match a single file name component, so a ‘/’ inside a group will signal an
 error. 

‘x|y’

 Inside of a group, matches either x or y. For example, ‘e(m|sh)-*’ matches any file
 beginning with em- or esh-. 

‘x#’

 Matches zero or more copies of the glob pattern x. For example, ‘fo#.el’ matches
 f.el, fo.el, foo.el, etc. 

‘x##’

 Matches one or more copies of the glob pattern x. Thus, ‘fo#.el’ matches fo.el,
 foo.el, fooo.el, etc. 

‘x~y’

 Matches anything that matches the pattern x but not y. For example,
 ‘[[:digit:]]#~4?’ matches 1 and 12, but not 42. Note that unlike in Zsh, only a
 single ‘~’ operator can be used in a pattern, and it cannot be inside of a group
 like ‘(x~y)’. 

-----------------------------------------------------------------------------------------------

Previous: Globbing, Up: Expansion   [Contents][Index]

3.3 Argument Predication and Modification

Eshell supports argument predication, to filter elements of a glob, and argument
modification, to manipulate argument values. These are similar to glob qualifiers in
Zsh (see Glob Qualifiers in The Z Shell Manual). 

Predicates and modifiers are introduced with ‘(filters)’ after any list argument,
where filters is a list of predicates or modifiers. For example, ‘*(.)’ expands to all
regular files in the current directory and ‘*(^@:U^u0)’ expands to all non-symlinks
not owned by root, upper-cased. 

Some predicates and modifiers accept string parameters, such as ‘*(u'user')’, which
matches all files owned by user. These parameters must be surrounded by delimiters;
you can use any of the following pairs of delimiters: "…", '…', /…/, |…|, (…), […], <…>,
or {…}. 

You can customize the syntax and behavior of predicates and modifiers in Eshell via
the Customize group eshell-pred (see Easy Customization in The GNU Emacs Manual). 

* Argument Predicates
* Argument Modifiers

-----------------------------------------------------------------------------------------------

Next: Argument Modifiers, Up: Argument Predication and Modification   [Contents]
[Index]

3.3.1 Argument Predicates

You can use argument predicates to filter lists of file names based on various
properties of those files. This is most useful when combined with globbing, but can be
used on any list of files names. Eshell supports the following argument predicates: 

‘/’

 Matches directories. 

‘.’ (Period)

 Matches regular files. 

‘@’

 Matches symbolic links. 

‘=’

 Matches sockets. 

‘p’

 Matches named pipes. 

‘%’

 Matches block or character devices. 

‘%b’

 Matches block devices. 

‘%c’

 Matches character devices. 

‘*’

 Matches regular files that can be executed by the current user. 

‘r’
‘A’
‘R’

 Matches files that are readable by their owners (‘r’), their groups (‘A’), or the
 world (‘R’). 

‘w’
‘I’
‘W’

 Matches files that are writable by their owners (‘w’), their groups (‘I’), or the
 world (‘W’). 

‘x’
‘E’
‘X’

 Matches files that are executable by their owners (‘x’), their groups (‘E’), or the
 world (‘X’). 

‘s’

 Matches files with the setuid flag set. 

‘S’

 Matches files with the setgid flag set. 

‘t’

 Matches files with the sticky bit set. 

‘U’

 Matches files owned by the current effective user ID. 

‘G’

 Matches files owned by the current effective group ID. 

‘l[+-]n’

 Matches files with n links. With + (or -), matches files with more than (or less
 than) n links, respectively. 

‘uuid’
‘u'user-name'’

 Matches files owned by user ID uid or user name user-name. 

‘ggid’
‘g'group-name'’

 Matches files owned by group ID gid or group name group-name. 

‘a[unit][+-]n’
‘a[+-]'file'’

 Matches files last accessed exactly n days ago. With + (or -), matches files
 accessed more than (or less than) n days ago, respectively. 

 With unit, n is a quantity in that unit of time, so ‘aw-1’ matches files last
 accessed within one week. unit can be ‘M’ (30-day months), ‘w’ (weeks), ‘h’
 (hours), ‘m’ (minutes), or ‘s’ (seconds). 

 If file is specified instead, compare against the modification time of file. Thus,
 ‘a-'hello.txt'’ matches all files accessed after hello.txt was last accessed. 

‘m[unit][+-]n’
‘m[+-]'file'’

 Like ‘a’, but examines modification time. 

‘c[unit][+-]n’
‘c[+-]'file'’

 Like ‘a’, but examines status change time. 

‘L[unit][+-]n’

 Matches files exactly n bytes in size. With + (or -), matches files larger than (or
 smaller than) n bytes, respectively. 

 With unit, n is a quantity in that unit of size, so ‘Lm+5’ matches files larger
 than 5 MiB in size. unit can be one of the following (case-insensitive) characters:
 ‘m’ (megabytes), ‘k’ (kilobytes), or ‘p’ (512-byte blocks). 

The ‘^’ and ‘-’ operators are not argument predicates themselves, but they modify the
behavior of all subsequent predicates. ‘^’ inverts the meaning of subsequent
predicates, so ‘*(^RWX)’ expands to all files whose permissions disallow the world
from accessing them in any way (i.e., reading, writing to, or modifying them). When
examining a symbolic link, ‘-’ applies the subsequent predicates to the link’s target
instead of the link itself. 

-----------------------------------------------------------------------------------------------

Previous: Argument Predicates, Up: Argument Predication and Modification   [Contents]
[Index]

3.3.2 Argument Modifiers

You can use argument modifiers to manipulate argument values. For example, you can
sort lists, remove duplicate values, capitalize words, etc. All argument modifiers are
prefixed by ‘:’, so ‘$exec-path(:h:u:x/^\/home/)’ lists all of the unique parent
directories of the elements in exec-path, excluding those in /home. 

‘E’

 Re-evaluates the value as an Eshell argument. For example, if foo is "${echo hi}",
 then the result of ‘$foo(:E)’ is hi. 

‘L’

 Converts the value to lower case. 

‘U’

 Converts the value to upper case. 

‘C’

 Capitalizes the value. 

‘h’

 Treating the value as a file name, gets the directory name (the “head”). For
 example, ‘foo/bar/baz.el(:h)’ expands to ‘foo/bar/’. 

‘t’

 Treating the value as a file name, gets the base name (the “tail”). For example,
 ‘foo/bar/baz.el(:h)’ expands to ‘baz.el’. 

‘e’

 Treating the value as a file name, gets the final extension of the file, excluding
 the dot. For example, ‘foo.tar.gz(:e)’ expands to gz. 

‘r’

 Treating the value as a file name, gets the file name excluding the final
 extension. For example, ‘foo/bar/baz.tar.gz(:r)’ expands to ‘foo/bar/baz.tar’. 

‘q’

 Marks that the value should be interpreted by Eshell literally, so that any special
 characters like ‘$’ no longer have any special meaning. 

‘s/pattern/replace/’

 Replaces the first instance of the regular expression pattern with replace. Signals
 an error if no match is found. 

 As with other modifiers taking string parameters, you can use different delimiters
 to separate pattern and replace, such as ‘s'…'…'’, ‘s[…][…]’, or even ‘s[…]/…/’. 

‘gs/pattern/replace/’

 Replaces all instances of the regular expression pattern with replace. 

‘i/pattern/’

 Filters a list of values to include only the elements matching the regular
 expression pattern. 

‘x/pattern/’

 Filters a list of values to exclude all the elements matching the regular
 expression pattern. 

‘S’
‘S/pattern/’

 Splits the value using the regular expression pattern as a delimiter. If pattern is
 omitted, split on spaces. 

‘j’
‘j/delim/’

 Joins a list of values, inserting the string delim between each value. If delim is
 omitted, use a single space as the delimiter. 

‘o’

 Sorts a list of strings in ascending lexicographic order, comparing pairs of
 characters according to their character codes (see Text Comparison in The Emacs
 Lisp Reference Manual). 

‘O’

 Sorts a list of strings in descending lexicographic order. 

‘u’

 Removes any duplicate elements from a list of values. 

‘R’

 Reverses the order of a list of values. 

-----------------------------------------------------------------------------------------------

Next: Extension modules, Previous: Expansion, Up: Eshell   [Contents][Index]

4 Input/Output

Since Eshell does not communicate with a terminal like most command shells, IO is a
little different. 

* Visual Commands
* Redirection
* Pipelines

-----------------------------------------------------------------------------------------------

Next: Redirection, Up: Input/Output   [Contents][Index]

4.1 Visual Commands

If you try to run programs from within Eshell that are not line-oriented, such as
programs that use ncurses, you will just get garbage output, since the Eshell buffer
is not a terminal emulator. Eshell solves this problem by running such programs in
Emacs’s terminal emulator. 

Programs that need a terminal to display output properly are referred to in this
manual as “visual commands”, because they are not simply line-oriented. You must tell
Eshell which commands are visual, by adding them to eshell-visual-commands; for commands
that are visual for only certain sub-commands – e.g., ‘git log’ but not ‘git status’ –
use eshell-visual-subcommands; and for commands that are visual only when passed certain
options, use eshell-visual-options. 

Caution: Some tools such as Git use the pager ‘less’ by default to paginate their
output but call it with its ‘-F’ option. This option causes ‘less’ to echo the output
instead of paginating it if the output is less than one page long. This causes
undesirable behavior if, e.g., ‘git diff’, is defined as a visual subcommand. It’ll
work if the output is big enough and fail if it is less than one page long. If that
occurs to you, search for configuration options for calling ‘less’ without the ‘-F’
option. For Git, you can do that using ‘git config --global core.pager 'less -+F'’. 

If you want the buffers created by visual programs killed when the program exits,
customize the variable eshell-destroy-buffer-when-process-dies to a non-nil value; the
default is nil. 

-----------------------------------------------------------------------------------------------

Next: Pipelines, Previous: Visual Commands, Up: Input/Output   [Contents][Index]

4.2 Redirection

Redirection in Eshell is similar to that of other command shells. You can use the
output redirection operators > and >>, but there is not yet any support for input
redirection. In the cases below, fd specifies the file descriptor to redirect; if not
specified, file descriptor 1 (standard output) will be used by default. 

> dest
fd> dest

 Redirect output to dest, overwriting its contents with the new output. 

>> dest
fd>> dest

 Redirect output to dest, appending it to the existing contents of dest. 

>>> dest
fd>>> dest

 Redirect output to dest, inserting it at the current mark if dest is a buffer, at
 the beginning of the file if dest is a file, or otherwise behaving the same as >>. 

&> dest
>& dest

 Redirect both standard output and standard error to dest, overwriting its contents
 with the new output. 

&>> dest
>>& dest

 Redirect both standard output and standard error to dest, appending it to the
 existing contents of dest. 

&>>> dest
>>>& dest

 Redirect both standard output and standard error to dest, inserting it like with
 >>> dest. 

>&other-fd
fd>&other-fd

 Duplicate the file descriptor other-fd to fd (or 1 if unspecified). The order in
 which this is used is significant, so 

command > file 2>&1

 redirects both standard output and standard error to file, whereas 

command 2>&1 > file

 only redirects standard output to file (and sends standard error to the display via
 standard output’s original handle). 

Eshell supports redirecting output to several different types of targets: 

* files, including virtual targets (see below); 
* buffers (see Buffers in GNU Emacs Lisp Reference Manual); 
* markers (see Markers in GNU Emacs Lisp Reference Manual); 
* processes (see Processes in GNU Emacs Lisp Reference Manual); and 
* symbols (see Symbols in GNU Emacs Lisp Reference Manual). 

* Virtual Targets

4.2.1 Virtual Targets

Virtual targets are mapping of device names to functions. Eshell comes with four
virtual devices: 

/dev/null

 Does nothing with the output passed to it. 

/dev/eshell

 Writes the text passed to it to the display. 

/dev/kill

 Adds the text passed to it to the kill ring. 

/dev/clip

 Adds the text passed to it to the clipboard. 

You can, of course, define your own virtual targets. They are defined by adding a list
of the form ‘("/dev/name" function mode)’ to eshell-virtual-targets. The first element
is the device name; function may be either a lambda or a function name. If mode is nil,
then the function is the output function; if it is non-nil, then the function is passed
the redirection mode as a symbol–overwrite for >, append for >>, or insert for >>>–and
the function is expected to return the output function. 

The output function is called once on each line of output until nil is passed,
indicating end of output. 

-----------------------------------------------------------------------------------------------

Previous: Redirection, Up: Input/Output   [Contents][Index]

4.3 Pipelines

As with most other shells, Eshell supports pipelines to pass the output of one command
the input of the next command. You can send the standard output of one command to the
standard input of another using the | operator. For example, 

~ $ echo hello | rev
olleh

To send both the standard output and standard error of a command to another command’s
input, you can use the |& operator. 

* Running Shell Pipelines Natively

4.3.1 Running Shell Pipelines Natively

When constructing shell pipelines that will move a lot of data, it is a good idea to
bypass Eshell’s own pipelining support and use the operating system shell’s instead.
This is especially relevant when executing commands on a remote machine using Eshell’s
Tramp integration: using the remote shell’s pipelining avoids copying the data which
will flow through the pipeline to local Emacs buffers and then right back again. 

Eshell recognizes a special syntax to make it easier to convert pipelines so as to
bypass Eshell’s pipelining. Prefixing at least one |, < or > with an asterisk marks a
command as intended for the operating system shell. To make it harder to invoke this
functionality accidentally, it is also required that the asterisk be preceded by
whitespace or located at the start of input. For example, 

 cat *.ogg *| my-cool-decoder >file

Executing this command will not copy all the data in the *.ogg files, nor the decoded
data, into Emacs buffers, as would normally happen. 

The command is interpreted as extending up to the next | character which is not
preceded by an unescaped asterisk following whitespace, or the end of the input if
there is no such character. Thus, all < and > redirections occurring before the next
asterisk-unprefixed | are implicitly prefixed with (whitespace and) asterisks. An
exception is that Eshell-specific redirects right at the end of the command are
excluded. This allows input like this: 

 foo *| baz >#<buffer quux>

which is equivalent to input like this: 

 sh -c "foo | baz" >#<buffer quux>
-----------------------------------------------------------------------------------------------

Next: Bugs and ideas, Previous: Input/Output, Up: Eshell   [Contents][Index]

5 Extension modules

Eshell provides a facility for defining extension modules so that they can be disabled
and enabled without having to unload and reload them, and to provide a common parent
Customize group for the modules.9 

* Optional modules
* Writing a module

-----------------------------------------------------------------------------------------------

Next: Writing a module, Up: Extension modules   [Contents][Index]

5.1 Optional modules

In addition to the various modules enabled by default (documented above), Eshell
provides several other modules which are not enabled by default. If you want to enable
these, you can add them to eshell-modules-list. 

* Key rebinding
* Smart scrolling
* Electric forward slash
* Tramp extensions
* Extra built-in commands

-----------------------------------------------------------------------------------------------

Next: Smart scrolling, Up: Optional modules   [Contents][Index]

5.1.1 Key rebinding

This module allows for special keybindings that only take effect while the point is in
a region of input text. The default keybindings mimic the bindings used in other
shells when the user is editing new input text. To enable this module, add
eshell-rebind to eshell-modules-list. 

For example, it binds C-a to move to the beginning of the input text, C-u to kill the
current input text, and C-w to backward-kill-word. If the history module is enabled, it
also binds C-p and C-n to move through the input history. 

If eshell-confine-point-to-input is non-nil, this module prevents certain commands from
causing the point to leave the input area, such as backward-word, previous-line, etc. 

-----------------------------------------------------------------------------------------------

Next: Electric forward slash, Previous: Key rebinding, Up: Optional modules  
[Contents][Index]

5.1.2 Smart scrolling

This module combines the facility of normal, modern shells with some of the
edit/review concepts inherent in the design of Plan 9’s 9term. To enable it, add
eshell-smart to eshell-modules-list. 

* When you invoke a command, it is assumed that you want to read the output of that
 command. 
* If the output is not what you wanted, it is assumed that you will want to edit, and
 then resubmit a refined version of that command. 
* If the output is valid, pressing any self-inserting character key will jump to end of
 the buffer and insert that character, in order to begin entry of a new command. 
* If you show an intention to edit the previous command – by moving around within it –
 then the next self-inserting characters will insert *there*, instead of at the bottom
 of the buffer. 
* If you show an intention to review old commands, such as M-p or M-r, point will jump
 to the bottom of the buffer before invoking that command. 
* If none of the above has happened yet (i.e. your point is just sitting on the
 previous command), you can use SPC and BACKSPACE (or Delete) to page forward and
 backward through the output of the last command only. It will constrain the movement
 of the point and window so that the maximum amount of output is always displayed at
 all times. 
* While output is being generated from a command, the window will be constantly
 reconfigured (until it would otherwise make no difference) in order to always show
 you the most output from the command possible. This happens if you change window
 sizes, scroll, etc. 

-----------------------------------------------------------------------------------------------

Next: Tramp extensions, Previous: Smart scrolling, Up: Optional modules   [Contents]
[Index]

5.1.3 Electric forward slash

To help with supplying absolute file name arguments to remote commands, you can add
the eshell-elecslash module to eshell-modules-list. Then, typing / as the first character
of a command line argument will automatically insert the Tramp prefix /method:host:.
If this is not what you want (e.g. because you want to refer to a local file), you can
type another / to undo the automatic insertion. Typing ~/ also inserts the Tramp
prefix. The automatic insertion applies only when default-directory is remote and the
command is a Lisp function. In particular, typing arguments to external commands
doesn’t insert the prefix. 

The result is that in most cases of supplying absolute file name arguments to commands
you should see the Tramp prefix inserted automatically only when that’s what you’d
reasonably expect. This frees you from having to keep track of whether commands are
Lisp functions or external when typing command line arguments. For example, suppose
you execute 

 cd /ssh:root@example.com:
 find /etc -name "*gnu*"

and in reviewing the output of the command, you identify a file /etc/gnugnu that
should be moved somewhere else. So you type 

 mv /etc/gnugnu /tmp

But since mv refers to the local Lisp function eshell/mv, not a remote shell command,
to say this is to request that the local file /etc/gnugnu be moved into the local /tmp
directory. After you add eshell-elecslash to eshell-modules-list, then when you type the
above mv invocation you will get the following input, which is what you intended: 

 mv /ssh:root@example.com:/etc/gnugnu /ssh:root@example.com:/tmp

The code that determines whether or not the Tramp prefix should be inserted uses
simple heuristics. A limitation of the current implementation is that it inspects
whether only the command at the very beginning of input is a Lisp function or external
program. Thus when chaining commands with the operators &&, ||, | and ;, the electric
forward slash is active only within the first command. 

-----------------------------------------------------------------------------------------------

Next: Extra built-in commands, Previous: Electric forward slash, Up: Optional modules 
 [Contents][Index]

5.1.4 Tramp extensions

This module adds built-in commands that use Tramp to handle running other commands as
different users, replacing the corresponding external commands. To enable it, add
eshell-tramp to eshell-modules-list. 

su ¶
sudo
doas

 Uses TRAMP’s su, sudo, or doas method (see Inline methods in The Tramp Manual) to
 run a command via su, sudo, or doas. 

-----------------------------------------------------------------------------------------------

Previous: Tramp extensions, Up: Optional modules   [Contents][Index]

5.1.5 Extra built-in commands

This module provides several extra built-in commands documented below, primarily for
working with lists of strings in Eshell. To enable it, add eshell-xtra to
eshell-modules-list. 

count ¶

 A wrapper around the function cl-count (see Searching Sequences in GNU Emacs Common
 Lisp Emulation). This command can be used for comparing lists of strings. 

expr ¶

 An implementation of expr using the Calc package. See The GNU Emacs Calculator. 

ff ¶

 Shorthand for the the function find-name-dired (see Dired and Find in The Emacs
 Editor). 

gf ¶

 Shorthand for the the function find-grep-dired (see Dired and Find in The Emacs
 Editor). 

intersection ¶

 A wrapper around the function cl-intersection (see Lists as Sets in GNU Emacs Common
 Lisp Emulation). This command can be used for comparing lists of strings. 

mismatch ¶

 A wrapper around the function cl-mismatch (see Searching Sequences in GNU Emacs
 Common Lisp Emulation). This command can be used for comparing lists of strings. 

set-difference ¶

 A wrapper around the function cl-set-difference (see Lists as Sets in GNU Emacs
 Common Lisp Emulation). This command can be used for comparing lists of strings. 

set-exclusive-or ¶

 A wrapper around the function cl-set-exclusive-or (see Lists as Sets in GNU Emacs
 Common Lisp Emulation). This command can be used for comparing lists of strings. 

substitute ¶

 A wrapper around the function cl-substitute (see Sequence Functions in GNU Emacs
 Common Lisp Emulation). This command can be used for comparing lists of strings. 

union ¶

 A wrapper around the function cl-union (see Lists as Sets in GNU Emacs Common Lisp
 Emulation). This command can be used for comparing lists of strings. 

-----------------------------------------------------------------------------------------------

Previous: Optional modules, Up: Extension modules   [Contents][Index]

5.2 Writing a module

An Eshell module is defined the same as any other library but with two additional
requirements: first, the module’s source file should be named em-name.el; second, the
module must define an autoloaded Customize group (see Customization in The Emacs Lisp
Reference Manual) with eshell-module as the parent group. In order to properly autoload
this group, you should wrap its definition with progn as follows: 

;;;###autoload
(progn
(defgroup eshell-my-module nil
  "My module lets you do very cool things in Eshell."
  :tag "My module"
  :group 'eshell-module))

Even if you don’t have any Customize options in your module, you should still define
the group so that Eshell can include your module in the Customize interface for
eshell-modules-list. 

-----------------------------------------------------------------------------------------------

Next: GNU Free Documentation License, Previous: Extension modules, Up: Eshell  
[Contents][Index]

6 Bugs and ideas

If you find a bug or misfeature, don’t hesitate to report it, by using M-x
report-emacs-bug. The same applies to feature requests. It is best to discuss one
thing at a time. If you find several unrelated bugs, please report them separately. 

Below is a list of some known problems with Eshell version 2.4.2, which is the version
included with Emacs 22. 

Differentiate between aliases and functions

 Allow for a Bash-compatible syntax, such as: 

alias arg=blah
function arg () { blah $* }
Pcomplete sometimes gets stuck

 You press TAB, but no completions appear, even though the directory has matching
 files. This behavior is rare. 

‘grep python $<rpm -qa>’ doesn’t work, but using ‘*grep’ does

 This happens because the grep Lisp function returns immediately, and then the
 asynchronous grep process expects to examine the temporary file, which has since
 been deleted. 

Problem with C-r repeating text

 If the text before point reads "./run", and you type C-r r u n, it will repeat the
 line for every character typed. 

Backspace doesn’t scroll back after continuing (in smart mode)

 Hitting space during a process invocation, such as make, will cause it to track the
 bottom of the output; but backspace no longer scrolls back. 

It’s not possible to fully unload-feature Eshell
Menu support was removed, but never put back
If an interactive process is currently running, M-! doesn’t work
Use a timer instead of sleep-for when killing child processes
Piping to a Lisp function is not supported

 Make it so that the Lisp command on the right of the pipe is repeatedly called with
 the input strings as arguments. This will require changing eshell-do-pipelines to
 handle non-process targets. 

Input redirection is not supported

 See the above entry. 

Problem running less without arguments on Windows

 The result in the Eshell buffer is: 

Spawning child process: invalid argument

 Also a new less buffer was created with nothing in it… (presumably this holds the
 output of less). 

 If less.exe is invoked from the Eshell command line, the expected output is written
 to the buffer. 

 Note that this happens on NT-Emacs 20.6.1 on Windows 2000. The term.el package and
 the supplied shell both use the cmdproxy program for running shells. 

Implement ‘-r’, ‘-n’ and ‘-s’ switches for cp
‘mv dir file.tar’ does not remove directories

 This is because the tar option –remove-files doesn’t do so. Should it be Eshell’s
 job? 

Bind standard-output and standard-error

 This would be so that if a Lisp function calls print, everything will happen as it
 should (albeit slowly). 

When an extension module fails to load, ‘cd /’ gives a Lisp error
If a globbing pattern returns one match, should it be a list?
Make sure syntax table is correct in Eshell mode

 So that M-DEL acts in a predictable manner, etc. 

Allow all Eshell buffers to share the same history and list-dir
There is a problem with script commands that output to /dev/null

 If a script file, somewhere in the middle, uses ‘> /dev/null’, output from all
 subsequent commands is swallowed. 

Split up parsing of text after ‘$’ in esh-var.el

 Make it similar to the way that esh-arg.el is structured. Then add parsing of ‘$
 [?\n]’. 

After pressing M-RET, redisplay before running the next command
Argument predicates and modifiers should work anywhere in a path
/usr/local/src/editors/vim $ vi **/CVS(/)/Root(.)  Invalid regexp:
"Unmatched ( or \\("

 With zsh, the glob above expands to all files named Root in directories named CVS. 

Typing ‘echo ${locate locate}/binTAB’ results in a Lisp error

 Perhaps it should interpolate all permutations, and make that the globbing result,
 since otherwise hitting return here will result in “(list of filenames)/bin”, which
 is never valuable. Thus, one could cat only C backup files by using ‘ls ${identity
 *.c}~’. In that case, having an alias command name glob for identity would be
 useful. 

Once symbolic mode is supported for umask, implement chmod in Lisp
Create eshell-expand-file-name

 This would use a data table to transform things such as ‘~+’, ‘...’, etc. 

Abstract em-smart.el into smart-scroll.el

 It only really needs: to be hooked onto the output filter and the pre-command hook,
 and to have the input-end and input-start markers. And to know whether the last
 output group was “successful.” 

Allow for fully persisting the state of Eshell

 This would include: variables, history, buffer, input, dir stack, etc. 

Implement D as an argument predicate

 It means that files beginning with a dot should be included in the glob match. 

A comma in a predicate list should mean OR

 At the moment, this is not supported. 

‘(+ RET SPC TAB’ does not cause indent-according-to-mode to occur
Create eshell-auto-accumulate-list

 This is a list of commands for which, if the user presses RET, the text is staged
 as the next Eshell command, rather than being sent to the current interactive
 process. 

Display file and line number if an error occurs in a script
wait doesn’t work with process ids at the moment
Enable the direct-to-process input code in em-term.el
Problem with repeating ‘echo ${find /tmp}’

 With smart display active, if RET is held down, after a while it can’t keep up
 anymore and starts outputting blank lines. It only happens if an asynchronous
 process is involved… 

 I think the problem is that eshell-send-input is resetting the input target
 location, so that if the asynchronous process is not done by the time the next RET
 is received, the input processor thinks that the input is meant for the process;
 which, when smart display is enabled, will be the text of the last command line!
 That is a bug in itself. 

 In holding down RET while an asynchronous process is running, there will be a point
 in between termination of the process, and the running of eshell-post-command-hook,
 which would cause eshell-send-input to call eshell-copy-old-input, and then process
 that text as a command to be run after the process. Perhaps there should be a way
 of killing pending input between the death of the process, and the
 post-command-hook. 

Allow for a more aggressive smart display mode

 Perhaps toggled by a command, that makes each output block a smart display block. 

Create more meta variables

 ‘$!’

 The reason for the failure of the last disk command, or the text of the last
 Lisp error. 

 ‘$=’

 A special associate array, which can take references of the form ‘$=[REGEXP]’.
 It indexes into the directory ring. 

Eshell scripts can’t execute in the background
Support zsh’s “Parameter Expansion” syntax, i.e., ‘${name:-val}’
Create a mode eshell-browse

 It would treat the Eshell buffer as an outline. Collapsing the outline hides all of
 the output text. Collapsing again would show only the first command run in each
 directory 

Allow other revisions of a file to be referenced using ‘file{rev}’

 This would be expanded by eshell-expand-file-name (see above). 

Print “You have new mail” when the “Mail” icon is turned on
Implement M-| for Eshell
Implement input redirection

 If it’s a Lisp function, input redirection implies xargs (in a way…). If input
 redirection is added, also update the file-name-quote-list, and the delimiter list. 

Allow ‘#<word arg>’ as a generic syntax

 With the handling of word specified by an eshell-special-alist. 

In eshell-eval-using-options, allow a :complete tag

 It would be used to provide completion rules for that command. Then the macro will
 automagically define the completion function. 

For eshell-command-on-region, apply redirections to the result

 So that ‘+ > 'blah’ would cause the result of the + (using input from the current
 region) to be inserting into the symbol blah. 

 If an external command is being invoked, the input is sent as standard input, as if
 a ‘cat <region> |’ had been invoked. 

 If a Lisp command, or an alias, is invoked, then if the line has no newline
 characters, it is divided by whitespace and passed as arguments to the Lisp
 function. Otherwise, it is divided at the newline characters. Thus, invoking + on a
 series of numbers will add them; min would display the smallest figure, etc. 

Write eshell-script-mode as a minor mode

 It would provide syntax, abbrev, highlighting and indenting support like
 emacs-lisp-mode and shell-mode. 

In the history mechanism, finish the Bash-style support

 This means ‘!n’, ‘!#’, ‘!:%’, and ‘!:1-’ as separate from ‘!:1*’. 

Support the -n command line option for history
Implement fc in Lisp
Specifying a frame as a redirection target should imply the currently active window’s
buffer
Implement ‘>func-or-func-list’

 This would allow for an “output translators”, that take a function to modify output
 with, and a target. Devise a syntax that works well with pipes, and can accommodate
 multiple functions (i.e., ‘>'(upcase regexp-quote)’ or ‘>'upcase’). 

Allow Eshell to read/write to/from standard input and output

 This would be optional, rather than always using the Eshell buffer. This would
 allow it to be run from the command line (perhaps). 

Write a help command

 It would call subcommands with --help, or -h or /?, as appropriate. 

Implement stty in Lisp
Support rc’s matching operator, e.g., ‘~ (list) regexp’
Implement bg and fg as editors of eshell-process-list

 Using bg on a process that is already in the background does nothing. Specifying
 redirection targets replaces (or adds) to the list current being used. 

Have jobs print only the processes for the current shell
How can Eshell learn if a background process has requested input?
Make a customizable syntax table for redirects

 This way, the user could change it to use rc syntax: ‘>[2=1]’. 

Allow ‘$_[-1]’, which would indicate the last element of the array
Make ‘$x[*]’ equal to listing out the full contents of ‘x’

 Return them as a list, so that ‘$_[*]’ is all the arguments of the last command. 

Copy ANSI code handling from term.el into em-term.el

 Make it possible for the user to send char-by-char to the underlying process.
 Ultimately, I should be able to move away from using term.el altogether, since
 everything but the ANSI code handling is already part of Eshell. Then, things would
 work correctly on MS-Windows as well (which doesn’t have /bin/sh, although term.el
 tries to use it). 

Make the shell spawning commands be visual

 That is, make (su, bash, ssh, etc.) be part of eshell-visual-commands. The only
 exception is if the shell is being used to invoke a single command. Then, the
 behavior should be based on what that command is. 

Create a smart viewing command named open

 This would search for some way to open its argument (similar to opening a file in
 the Windows Explorer). 

Alias read to be the same as open, only read-only
Write a tail command which uses view-file

 It would move point to the end of the buffer, and then turns on auto-revert mode in
 that buffer at frequent intervals—and a head alias which assumes an upper limit of
 eshell-maximum-line-length characters per line. 

Make dgrep load dired, mark everything, then invoke dired-do-search
Write mesh.c

 This would run Emacs with the appropriate arguments to invoke Eshell only. That
 way, it could be listed as a login shell. 

Use an intangible PS2 string for multi-line input prompts
Auto-detect when a command is visual, by checking TERMCAP usage
The first keypress after M-x watson triggers

 eshell-send-input 

Make / more electric

 so that it automatically expands and corrects file names, beyond what the
 em-elecslash module is able to do. Or make file name completion for Pcomplete
 auto-expand ‘/u/i/stdTAB’ to ‘/usr/include/stdTAB’. 

Write the pushd stack to disk along with last-dir-ring
Add options to eshell/cat which would allow it to sort and uniq
Implement wc in Lisp

 Add support for counting sentences, paragraphs, pages, etc. 

Once piping is added, implement sort and uniq in Lisp
Implement touch in Lisp
Implement comm in Lisp
Implement an epatch command in Lisp

 This would call ediff-patch-file, or ediff-patch-buffer, depending on its argument. 

Have an option such that ‘ls -l’ generates a dired buffer
Write a version of xargs based on command rewriting

 That is, ‘find X | xargs Y’ would be indicated using ‘Y ${find X}’. Maybe
 eshell-do-pipelines could be changed to perform this on-thy-fly rewriting. 

Write an alias for less that brings up a view-mode buffer

 Such that the user can press SPC and DEL, and then q to return to Eshell. It would
 be equivalent to: ‘X > #<buffer Y>; view-buffer #<buffer Y>’. 

Make eshell-mode as much a full citizen as shell-mode

 Everywhere in Emacs where shell-mode is specially noticed, add eshell-mode there. 

Permit the umask to be selectively set on a cp target
Problem using M-x eshell after using eshell-command

 If the first thing that I do after entering Emacs is to run eshell-command and
 invoke ls, and then use M-x eshell, it doesn’t display anything. 

M-RET during a long command (using smart display) doesn’t work

 Since it keeps the cursor up where the command was invoked. 

-----------------------------------------------------------------------------------------------

Next: Concept Index, Previous: Bugs and ideas, Up: Eshell   [Contents][Index]

Appendix A GNU Free Documentation License

Version 1.3, 3 November 2008 
Copyright © 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
https://fsf.org/

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.

0 PREAMBLE 

 The purpose of this License is to make a manual, textbook, or other functional and
 useful document free in the sense of freedom: to assure everyone the effective
 freedom to copy and redistribute it, with or without modifying it, either
 commercially or noncommercially. Secondarily, this License preserves for the author
 and publisher a way to get credit for their work, while not being considered
 responsible for modifications made by others. 

 This License is a kind of “copyleft”, which means that derivative works of the
 document must themselves be free in the same sense. It complements the GNU General
 Public License, which is a copyleft license designed for free software. 

 We have designed this License in order to use it for manuals for free software,
 because free software needs free documentation: a free program should come with
 manuals providing the same freedoms that the software does. But this License is not
 limited to software manuals; it can be used for any textual work, regardless of
 subject matter or whether it is published as a printed book. We recommend this
 License principally for works whose purpose is instruction or reference. 

1 APPLICABILITY AND DEFINITIONS 

 This License applies to any manual or other work, in any medium, that contains a
 notice placed by the copyright holder saying it can be distributed under the terms of
 this License. Such a notice grants a world-wide, royalty-free license, unlimited in
 duration, to use that work under the conditions stated herein. The “Document”, below,
 refers to any such manual or work. Any member of the public is a licensee, and is
 addressed as “you”. You accept the license if you copy, modify or distribute the work
 in a way requiring permission under copyright law. 

 A “Modified Version” of the Document means any work containing the Document or a
 portion of it, either copied verbatim, or with modifications and/or translated into
 another language. 

 A “Secondary Section” is a named appendix or a front-matter section of the Document
 that deals exclusively with the relationship of the publishers or authors of the
 Document to the Document’s overall subject (or to related matters) and contains
 nothing that could fall directly within that overall subject. (Thus, if the Document
 is in part a textbook of mathematics, a Secondary Section may not explain any
 mathematics.) The relationship could be a matter of historical connection with the
 subject or with related matters, or of legal, commercial, philosophical, ethical or
 political position regarding them. 

 The “Invariant Sections” are certain Secondary Sections whose titles are designated,
 as being those of Invariant Sections, in the notice that says that the Document is
 released under this License. If a section does not fit the above definition of
 Secondary then it is not allowed to be designated as Invariant. The Document may
 contain zero Invariant Sections. If the Document does not identify any Invariant
 Sections then there are none. 

 The “Cover Texts” are certain short passages of text that are listed, as Front-Cover
 Texts or Back-Cover Texts, in the notice that says that the Document is released
 under this License. A Front-Cover Text may be at most 5 words, and a Back-Cover Text
 may be at most 25 words. 

 A “Transparent” copy of the Document means a machine-readable copy, represented in a
 format whose specification is available to the general public, that is suitable for
 revising the document straightforwardly with generic text editors or (for images
 composed of pixels) generic paint programs or (for drawings) some widely available
 drawing editor, and that is suitable for input to text formatters or for automatic
 translation to a variety of formats suitable for input to text formatters. A copy
 made in an otherwise Transparent file format whose markup, or absence of markup, has
 been arranged to thwart or discourage subsequent modification by readers is not
 Transparent. An image format is not Transparent if used for any substantial amount of
 text. A copy that is not “Transparent” is called “Opaque”. 

 Examples of suitable formats for Transparent copies include plain ASCII without
 markup, Texinfo input format, LaTeX input format, SGML or XML using a publicly
 available DTD, and standard-conforming simple HTML, PostScript or PDF designed for
 human modification. Examples of transparent image formats include PNG, XCF and JPG.
 Opaque formats include proprietary formats that can be read and edited only by
 proprietary word processors, SGML or XML for which the DTD and/or processing tools
 are not generally available, and the machine-generated HTML, PostScript or PDF
 produced by some word processors for output purposes only. 

 The “Title Page” means, for a printed book, the title page itself, plus such
 following pages as are needed to hold, legibly, the material this License requires to
 appear in the title page. For works in formats which do not have any title page as
 such, “Title Page” means the text near the most prominent appearance of the work’s
 title, preceding the beginning of the body of the text. 

 The “publisher” means any person or entity that distributes copies of the Document to
 the public. 

 A section “Entitled XYZ” means a named subunit of the Document whose title either is
 precisely XYZ or contains XYZ in parentheses following text that translates XYZ in
 another language. (Here XYZ stands for a specific section name mentioned below, such
 as “Acknowledgements”, “Dedications”, “Endorsements”, or “History”.) To “Preserve the
 Title” of such a section when you modify the Document means that it remains a section
 “Entitled XYZ” according to this definition. 

 The Document may include Warranty Disclaimers next to the notice which states that
 this License applies to the Document. These Warranty Disclaimers are considered to be
 included by reference in this License, but only as regards disclaiming warranties:
 any other implication that these Warranty Disclaimers may have is void and has no
 effect on the meaning of this License. 

2 VERBATIM COPYING 

 You may copy and distribute the Document in any medium, either commercially or
 noncommercially, provided that this License, the copyright notices, and the license
 notice saying this License applies to the Document are reproduced in all copies, and
 that you add no other conditions whatsoever to those of this License. You may not use
 technical measures to obstruct or control the reading or further copying of the
 copies you make or distribute. However, you may accept compensation in exchange for
 copies. If you distribute a large enough number of copies you must also follow the
 conditions in section 3. 

 You may also lend copies, under the same conditions stated above, and you may
 publicly display copies. 

3 COPYING IN QUANTITY 

 If you publish printed copies (or copies in media that commonly have printed covers)
 of the Document, numbering more than 100, and the Document’s license notice requires
 Cover Texts, you must enclose the copies in covers that carry, clearly and legibly,
 all these Cover Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
 the back cover. Both covers must also clearly and legibly identify you as the
 publisher of these copies. The front cover must present the full title with all words
 of the title equally prominent and visible. You may add other material on the covers
 in addition. Copying with changes limited to the covers, as long as they preserve the
 title of the Document and satisfy these conditions, can be treated as verbatim
 copying in other respects. 

 If the required texts for either cover are too voluminous to fit legibly, you should
 put the first ones listed (as many as fit reasonably) on the actual cover, and
 continue the rest onto adjacent pages. 

 If you publish or distribute Opaque copies of the Document numbering more than 100,
 you must either include a machine-readable Transparent copy along with each Opaque
 copy, or state in or with each Opaque copy a computer-network location from which the
 general network-using public has access to download using public-standard network
 protocols a complete Transparent copy of the Document, free of added material. If you
 use the latter option, you must take reasonably prudent steps, when you begin
 distribution of Opaque copies in quantity, to ensure that this Transparent copy will
 remain thus accessible at the stated location until at least one year after the last
 time you distribute an Opaque copy (directly or through your agents or retailers) of
 that edition to the public. 

 It is requested, but not required, that you contact the authors of the Document well
 before redistributing any large number of copies, to give them a chance to provide
 you with an updated version of the Document. 

4 MODIFICATIONS 

 You may copy and distribute a Modified Version of the Document under the conditions
 of sections 2 and 3 above, provided that you release the Modified Version under
 precisely this License, with the Modified Version filling the role of the Document,
 thus licensing distribution and modification of the Modified Version to whoever
 possesses a copy of it. In addition, you must do these things in the Modified
 Version: 

 1 Use in the Title Page (and on the covers, if any) a title distinct from that of the
 Document, and from those of previous versions (which should, if there were any, be
 listed in the History section of the Document). You may use the same title as a
 previous version if the original publisher of that version gives permission. 
 2 List on the Title Page, as authors, one or more persons or entities responsible for
 authorship of the modifications in the Modified Version, together with at least
 five of the principal authors of the Document (all of its principal authors, if it
 has fewer than five), unless they release you from this requirement. 
 3 State on the Title page the name of the publisher of the Modified Version, as the
 publisher. 
 4 Preserve all the copyright notices of the Document. 
 5 Add an appropriate copyright notice for your modifications adjacent to the other
 copyright notices. 
 6 Include, immediately after the copyright notices, a license notice giving the
 public permission to use the Modified Version under the terms of this License, in
 the form shown in the Addendum below. 
 7 Preserve in that license notice the full lists of Invariant Sections and required
 Cover Texts given in the Document’s license notice. 
 8 Include an unaltered copy of this License. 
 9 Preserve the section Entitled “History”, Preserve its Title, and add to it an item
 stating at least the title, year, new authors, and publisher of the Modified
 Version as given on the Title Page. If there is no section Entitled “History” in
 the Document, create one stating the title, year, authors, and publisher of the
 Document as given on its Title Page, then add an item describing the Modified
 Version as stated in the previous sentence. 
 10 Preserve the network location, if any, given in the Document for public access to
 a Transparent copy of the Document, and likewise the network locations given in
 the Document for previous versions it was based on. These may be placed in the
 “History” section. You may omit a network location for a work that was published
 at least four years before the Document itself, or if the original publisher of
 the version it refers to gives permission. 
 11 For any section Entitled “Acknowledgements” or “Dedications”, Preserve the Title
 of the section, and preserve in the section all the substance and tone of each of
 the contributor acknowledgements and/or dedications given therein. 
 12 Preserve all the Invariant Sections of the Document, unaltered in their text and
 in their titles. Section numbers or the equivalent are not considered part of the
 section titles. 
 13 Delete any section Entitled “Endorsements”. Such a section may not be included in
 the Modified Version. 
 14 Do not retitle any existing section to be Entitled “Endorsements” or to conflict
 in title with any Invariant Section. 
 15 Preserve any Warranty Disclaimers. 

 If the Modified Version includes new front-matter sections or appendices that qualify
 as Secondary Sections and contain no material copied from the Document, you may at
 your option designate some or all of these sections as invariant. To do this, add
 their titles to the list of Invariant Sections in the Modified Version’s license
 notice. These titles must be distinct from any other section titles. 

 You may add a section Entitled “Endorsements”, provided it contains nothing but
 endorsements of your Modified Version by various parties—for example, statements of
 peer review or that the text has been approved by an organization as the
 authoritative definition of a standard. 

 You may add a passage of up to five words as a Front-Cover Text, and a passage of up
 to 25 words as a Back-Cover Text, to the end of the list of Cover Texts in the
 Modified Version. Only one passage of Front-Cover Text and one of Back-Cover Text may
 be added by (or through arrangements made by) any one entity. If the Document already
 includes a cover text for the same cover, previously added by you or by arrangement
 made by the same entity you are acting on behalf of, you may not add another; but you
 may replace the old one, on explicit permission from the previous publisher that
 added the old one. 

 The author(s) and publisher(s) of the Document do not by this License give permission
 to use their names for publicity for or to assert or imply endorsement of any
 Modified Version. 

5 COMBINING DOCUMENTS 

 You may combine the Document with other documents released under this License, under
 the terms defined in section 4 above for modified versions, provided that you include
 in the combination all of the Invariant Sections of all of the original documents,
 unmodified, and list them all as Invariant Sections of your combined work in its
 license notice, and that you preserve all their Warranty Disclaimers. 

 The combined work need only contain one copy of this License, and multiple identical
 Invariant Sections may be replaced with a single copy. If there are multiple
 Invariant Sections with the same name but different contents, make the title of each
 such section unique by adding at the end of it, in parentheses, the name of the
 original author or publisher of that section if known, or else a unique number. Make
 the same adjustment to the section titles in the list of Invariant Sections in the
 license notice of the combined work. 

 In the combination, you must combine any sections Entitled “History” in the various
 original documents, forming one section Entitled “History”; likewise combine any
 sections Entitled “Acknowledgements”, and any sections Entitled “Dedications”. You
 must delete all sections Entitled “Endorsements.” 

6 COLLECTIONS OF DOCUMENTS 

 You may make a collection consisting of the Document and other documents released
 under this License, and replace the individual copies of this License in the various
 documents with a single copy that is included in the collection, provided that you
 follow the rules of this License for verbatim copying of each of the documents in all
 other respects. 

 You may extract a single document from such a collection, and distribute it
 individually under this License, provided you insert a copy of this License into the
 extracted document, and follow this License in all other respects regarding verbatim
 copying of that document. 

7 AGGREGATION WITH INDEPENDENT WORKS 

 A compilation of the Document or its derivatives with other separate and independent
 documents or works, in or on a volume of a storage or distribution medium, is called
 an “aggregate” if the copyright resulting from the compilation is not used to limit
 the legal rights of the compilation’s users beyond what the individual works permit.
 When the Document is included in an aggregate, this License does not apply to the
 other works in the aggregate which are not themselves derivative works of the
 Document. 

 If the Cover Text requirement of section 3 is applicable to these copies of the
 Document, then if the Document is less than one half of the entire aggregate, the
 Document’s Cover Texts may be placed on covers that bracket the Document within the
 aggregate, or the electronic equivalent of covers if the Document is in electronic
 form. Otherwise they must appear on printed covers that bracket the whole aggregate. 

8 TRANSLATION 

 Translation is considered a kind of modification, so you may distribute translations
 of the Document under the terms of section 4. Replacing Invariant Sections with
 translations requires special permission from their copyright holders, but you may
 include translations of some or all Invariant Sections in addition to the original
 versions of these Invariant Sections. You may include a translation of this License,
 and all the license notices in the Document, and any Warranty Disclaimers, provided
 that you also include the original English version of this License and the original
 versions of those notices and disclaimers. In case of a disagreement between the
 translation and the original version of this License or a notice or disclaimer, the
 original version will prevail. 

 If a section in the Document is Entitled “Acknowledgements”, “Dedications”, or
 “History”, the requirement (section 4) to Preserve its Title (section 1) will
 typically require changing the actual title. 

9 TERMINATION 

 You may not copy, modify, sublicense, or distribute the Document except as expressly
 provided under this License. Any attempt otherwise to copy, modify, sublicense, or
 distribute it is void, and will automatically terminate your rights under this
 License. 

 However, if you cease all violation of this License, then your license from a
 particular copyright holder is reinstated (a) provisionally, unless and until the
 copyright holder explicitly and finally terminates your license, and (b) permanently,
 if the copyright holder fails to notify you of the violation by some reasonable means
 prior to 60 days after the cessation. 

 Moreover, your license from a particular copyright holder is reinstated permanently
 if the copyright holder notifies you of the violation by some reasonable means, this
 is the first time you have received notice of violation of this License (for any
 work) from that copyright holder, and you cure the violation prior to 30 days after
 your receipt of the notice. 

 Termination of your rights under this section does not terminate the licenses of
 parties who have received copies or rights from you under this License. If your
 rights have been terminated and not permanently reinstated, receipt of a copy of some
 or all of the same material does not give you any rights to use it. 

10 FUTURE REVISIONS OF THIS LICENSE 

 The Free Software Foundation may publish new, revised versions of the GNU Free
 Documentation License from time to time. Such new versions will be similar in spirit
 to the present version, but may differ in detail to address new problems or
 concerns. See https://www.gnu.org/licenses/. 

 Each version of the License is given a distinguishing version number. If the
 Document specifies that a particular numbered version of this License “or any later
 version” applies to it, you have the option of following the terms and conditions
 either of that specified version or of any later version that has been published
 (not as a draft) by the Free Software Foundation. If the Document does not specify a
 version number of this License, you may choose any version ever published (not as a
 draft) by the Free Software Foundation. If the Document specifies that a proxy can
 decide which future versions of this License can be used, that proxy’s public
 statement of acceptance of a version permanently authorizes you to choose that
 version for the Document. 

11 RELICENSING 

 “Massive Multiauthor Collaboration Site” (or “MMC Site”) means any World Wide Web
 server that publishes copyrightable works and also provides prominent facilities for
 anybody to edit those works. A public wiki that anybody can edit is an example of
 such a server. A “Massive Multiauthor Collaboration” (or “MMC”) contained in the
 site means any set of copyrightable works thus published on the MMC site. 

 “CC-BY-SA” means the Creative Commons Attribution-Share Alike 3.0 license published
 by Creative Commons Corporation, a not-for-profit corporation with a principal place
 of business in San Francisco, California, as well as future copyleft versions of
 that license published by that same organization. 

 “Incorporate” means to publish or republish a Document, in whole or in part, as part
 of another Document. 

 An MMC is “eligible for relicensing” if it is licensed under this License, and if
 all works that were first published under this License somewhere other than this
 MMC, and subsequently incorporated in whole or in part into the MMC, (1) had no
 cover texts or invariant sections, and (2) were thus incorporated prior to November
 1, 2008. 

 The operator of an MMC Site may republish an MMC contained in the site under
 CC-BY-SA on the same site at any time before August 1, 2009, provided the MMC is
 eligible for relicensing. 

ADDENDUM: How to use this License for your documents

To use this License in a document you have written, include a copy of the License in
the document and put the following copyright and license notices just after the title
page: 

  Copyright (C)  year  your name.
  Permission is granted to copy, distribute and/or modify this document
  under the terms of the GNU Free Documentation License, Version 1.3
  or any later version published by the Free Software Foundation;
  with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
  Texts.  A copy of the license is included in the section entitled ``GNU
  Free Documentation License''.

If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts, replace the
“with…Texts.” line with this: 

    with the Invariant Sections being list their titles, with
    the Front-Cover Texts being list, and with the Back-Cover Texts
    being list.

If you have Invariant Sections without Cover Texts, or some other combination of the
three, merge those two alternatives to suit the situation. 

If your document contains nontrivial examples of program code, we recommend releasing
these examples in parallel under your choice of free software license, such as the GNU
General Public License, to permit their use in free software. 

-----------------------------------------------------------------------------------------------

Next: Function and Variable Index, Previous: GNU Free Documentation License, Up:
Eshell   [Contents][Index]

Concept Index

 Jump to:     A   B   C   E   F   G   K   O   P   R   W     

   Index Entry     Section  
 -------------------------------------------------------------------------------------  
 A      
   argument modification:     Argument Predication and  
       Modification  
   argument predication:     Argument Predication and  
       Modification  
   author, how to reach:     Bugs and ideas  
   authors:     Contributors to Eshell  
 -------------------------------------------------------------------------------------  
 B      
   bugs, how to report them:     Bugs and ideas  
   bugs, known:     Bugs and ideas  
 -------------------------------------------------------------------------------------  
 C      
   character classes, in     Globbing  
   Eshell glob patterns:      
   character sets, in Eshell     Globbing  
   glob patterns:      
   command lookup order:     Invocation  
   complemented character     Globbing  
   sets, in Eshell glob      
   patterns:      
   contributors:     Contributors to Eshell  
 -------------------------------------------------------------------------------------  
 E      
   email to the author:     Bugs and ideas  
   Eshell, what it is:     Introduction  
   event designators:     History  
 -------------------------------------------------------------------------------------  
 F      
   FAQ:     Bugs and ideas  
 -------------------------------------------------------------------------------------  
 G      
   groups, in Eshell glob     Globbing  
   patterns:      
 -------------------------------------------------------------------------------------  
 K      
   known bugs:     Bugs and ideas  
 -------------------------------------------------------------------------------------  
 O      
   order of looking for     Invocation  
   commands:      
 -------------------------------------------------------------------------------------  
 P      
   problems, list of common:     Bugs and ideas  
 -------------------------------------------------------------------------------------  
 R      
   reporting bugs and ideas:     Bugs and ideas  
 -------------------------------------------------------------------------------------  
 W      
   what is Eshell?:     Introduction  
 -------------------------------------------------------------------------------------  

 Jump to:     A   B   C   E   F   G   K   O   P   R   W     
-----------------------------------------------------------------------------------------------

Next: Command Index, Previous: Concept Index, Up: Eshell   [Contents][Index]

Function and Variable Index

 Jump to:     $     
   E     

   Index Entry     Section  
 -------------------------------------------------------------------------------------  
 $      
   $$:     Variables  
   $*:     Aliases  
   $+:     Variables  
   $-:     Variables  
   $1, $2, …:     Aliases  
   $?:     Variables  
   $COLUMNS:     Variables  
   $INSIDE_EMACS:     Variables  
   $LINES:     Variables  
   $OLDPWD:     Variables  
   $PATH:     Variables  
   $PWD:     Variables  
   $_:     Variables  
 -------------------------------------------------------------------------------------  
 E      
   eshell-destroy-buffer-when-process-dies:     Visual Commands  
   eshell-eval-using-options:     Built-ins  
   eshell-expand-history-references:     History  
   eshell-glob-case-insensitive:     Globbing  
   eshell-lisp-form-nil-is-failure:     Variables  
   eshell-prefer-lisp-functions:     Invocation  
   eshell-prefer-lisp-variables:     Variables  
   eshell-source-file:     Scripts  
   eshell-virtual-targets:     Redirection  
 -------------------------------------------------------------------------------------  

 Jump to:     $     
   E     
-----------------------------------------------------------------------------------------------

Previous: Function and Variable Index, Up: Eshell   [Contents][Index]

Command Index

 Jump to:     .     
   A   B   C   D   E   F   G   H   I   J   K   L   M   O   P   R   S   T   
    U   W     

   Index Entry     Section  
 --------------------------------------------------------------------------------  
 .      
   .:     Built-ins  
   .:     Scripts  
 --------------------------------------------------------------------------------  
 A      
   addpath:     Built-ins  
   agrep:     Built-ins  
   alias:     Built-ins  
 --------------------------------------------------------------------------------  
 B      
   basename:     Built-ins  
 --------------------------------------------------------------------------------  
 C      
   cat:     Built-ins  
   cd:     Built-ins  
   clear:     Built-ins  
   clear-scrollback:     Built-ins  
   count:     Extra built-in commands  
   cp:     Built-ins  
 --------------------------------------------------------------------------------  
 D      
   date:     Built-ins  
   diff:     Built-ins  
   dirname:     Built-ins  
   dirs:     Built-ins  
   doas:     Tramp extensions  
   du:     Built-ins  
 --------------------------------------------------------------------------------  
 E      
   echo:     Built-ins  
   egrep:     Built-ins  
   env:     Built-ins  
   eshell-debug:     Built-ins  
   exit:     Built-ins  
   export:     Built-ins  
   expr:     Extra built-in commands  
 --------------------------------------------------------------------------------  
 F      
   ff:     Extra built-in commands  
   fgrep:     Built-ins  
 --------------------------------------------------------------------------------  
 G      
   gf:     Extra built-in commands  
   glimpse:     Built-ins  
   grep:     Built-ins  
 --------------------------------------------------------------------------------  
 H      
   history:     Built-ins  
   history:     History  
 --------------------------------------------------------------------------------  
 I      
   info:     Built-ins  
   intersection:     Extra built-in commands  
 --------------------------------------------------------------------------------  
 J      
   jobs:     Built-ins  
 --------------------------------------------------------------------------------  
 K      
   kill:     Built-ins  
 --------------------------------------------------------------------------------  
 L      
   listify:     Built-ins  
   ln:     Built-ins  
   locate:     Built-ins  
   ls:     Built-ins  
 --------------------------------------------------------------------------------  
 M      
   make:     Built-ins  
   man:     Built-ins  
   mismatch:     Extra built-in commands  
   mkdir:     Built-ins  
   mv:     Built-ins  
 --------------------------------------------------------------------------------  
 O      
   occur:     Built-ins  
 --------------------------------------------------------------------------------  
 P      
   popd:     Built-ins  
   printnl:     Built-ins  
   pushd:     Built-ins  
   pwd:     Built-ins  
 --------------------------------------------------------------------------------  
 R      
   remote access:     Remote Access  
   rm:     Built-ins  
   rmdir:     Built-ins  
 --------------------------------------------------------------------------------  
 S      
   set:     Built-ins  
   set-difference:     Extra built-in commands  
   set-exclusive-or:     Extra built-in commands  
   setq:     Built-ins  
   source:     Built-ins  
   source:     Scripts  
   su:     Tramp extensions  
   substitute:     Extra built-in commands  
   sudo:     Tramp extensions  
 --------------------------------------------------------------------------------  
 T      
   time:     Built-ins  
 --------------------------------------------------------------------------------  
 U      
   umask:     Built-ins  
   union:     Extra built-in commands  
   unset:     Built-ins  
 --------------------------------------------------------------------------------  
 W      
   wait:     Built-ins  
   which:     Built-ins  
   whoami:     Built-ins  
 --------------------------------------------------------------------------------  

 Jump to:     .     
   A   B   C   D   E   F   G   H   I   J   K   L   M   O   P   R   S   T   
    U   W     
-----------------------------------------------------------------------------------------------

Footnotes

(1)

Short for “Read-Eval-Print Loop”.

(2)

This is comparable to viewing the contents of a folder using a graphical display.

(3)

For the understandably curious, here is what that command looks like: But don’t let it
fool you; once you know what’s going on, it’s easier than it looks: ls -lt **/*.doc
(Lk+50aM+5).

(4)

To see the Lisp form that will be invoked, type this as the Eshell prompt:
eshell-parse-command 'echo hello'

(5)

Eshell would interpret a bare apostrophe (') as the start of a single-quoted string.

(6)

Command completion, as opposed to code completion, which is beyond the scope of
pcomplete.

(7)

Eshell has no string-manipulation expansions because the Elisp library already
provides many functions for this.

(8)

E.g., entering just ‘$var’ at the prompt is equivalent to entering the value of var at
the prompt.

(9)

ERC provides a similar module facility.
